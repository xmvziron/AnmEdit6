#include "WebGL.hpp"
#include "Supervisor.hpp"
#include "utils.hpp"
#include <new>
#include <SDL2/SDL.h>

// Provided for anyone who wants to recompile with new shaders without rerunning the premake script
#ifdef USE_C23_EMBED
    static const char fragShaderBytes[] = {
        #embed "ff.frag"
        , '\0'
    };

    static const char vertShaderBytes[] = {
        #embed "ff.vert"
        , '\0'
    };
#else
    #include "autogenerated/Embeds.hpp"
#endif

#define POSITION_ATTRIBUTE_INDEX 0
#define TEX_COORDS_ATTRIBUTE_INDEX 1
#define DIFFUSE_ATTRIBUTE_INDEX 2

namespace th06
{

GLuint createShader(const char *source, GLenum type, const char *descString)
{
    const char *fullShaderSource[32];
    GLint getRet = 0;
    GLuint shaderHandle = g_glFuncTable.glCreateShader(type);
    u32 shaderSourceIndex = 1;

    if (shaderHandle == 0)
    {
        goto fail;
    }

    fullShaderSource[0] = "#version 100\n";

    if (g_Supervisor.cfg.opts & (1 >> GCOS_DONT_USE_FOG))
    {
        fullShaderSource[shaderSourceIndex++] = "#define NO_FOG\n";
    }

    if (g_Supervisor.cfg.opts & (1 >> GCOS_DONT_USE_VERTEX_BUF))
    {
        fullShaderSource[shaderSourceIndex++] = "#define NO_VERTEX_BUFFER\n";
    }

    fullShaderSource[shaderSourceIndex] = source;

    g_glFuncTable.glShaderSource(shaderHandle, shaderSourceIndex + 1, fullShaderSource, NULL);
    g_glFuncTable.glCompileShader(shaderHandle);

    g_glFuncTable.glGetShaderiv(shaderHandle, GL_COMPILE_STATUS, &getRet);

    if (getRet)
    {
        return shaderHandle;
    }

    g_glFuncTable.glGetShaderiv(shaderHandle, GL_INFO_LOG_LENGTH, &getRet);

    if (getRet == 0)
    {
        utils::DebugPrint("Shader %s compilation failed and has no log!\n", descString);
    }
    else
    {
        char *log = new char[getRet];
        g_glFuncTable.glGetShaderInfoLog(shaderHandle, getRet, NULL, log);
        utils::DebugPrint("Shader %s compilation failed, log: \n%s", descString, log);
        delete[] log;
    }

fail:
    return 0;
}

bool linkProgram(GLuint programHandle)
{
    g_glFuncTable.glLinkProgram(programHandle);

    GLint getRet;

    g_glFuncTable.glGetProgramiv(programHandle, GL_LINK_STATUS, &getRet);

    if (getRet)
    {
        return true;
    }

    g_glFuncTable.glGetProgramiv(programHandle, GL_INFO_LOG_LENGTH, &getRet);

    if (getRet == 0)
    {
        utils::DebugPrint("Program link failed and has no log!");
        return false;
    }

    char *log = new char[getRet];
    g_glFuncTable.glGetProgramInfoLog(programHandle, getRet, NULL, log);
    utils::DebugPrint("Program link failed, log: \n%s", log);
    delete[] log;

    return false;
}

void WebGL::SetContextFlags()
{
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);
}

GfxInterface *WebGL::Create()
{
    WebGL *interface = new WebGL;

    if (!interface->Init())
    {
        return NULL;
    }

    return interface;
}

bool WebGL::Init()
{
    ZunMatrix identityMatrix;

    while (g_glFuncTable.glGetError() != GL_NO_ERROR)
    {
    }

    this->vertexShaderHandle = createShader(vertShaderBytes, GL_VERTEX_SHADER, "vertex");
    this->fragmentShaderHandle = createShader(fragShaderBytes, GL_FRAGMENT_SHADER, "fragment");
    this->programHandle = g_glFuncTable.glCreateProgram();
    
    if (this->vertexShaderHandle == 0 || this->fragmentShaderHandle == 0 || this->programHandle == 0)
    {
        goto fail;
    }

    g_glFuncTable.glAttachShader(this->programHandle, this->vertexShaderHandle);
    g_glFuncTable.glAttachShader(this->programHandle, this->fragmentShaderHandle);

    g_glFuncTable.glBindAttribLocation(this->programHandle, POSITION_ATTRIBUTE_INDEX, "position");
    g_glFuncTable.glBindAttribLocation(this->programHandle, TEX_COORDS_ATTRIBUTE_INDEX, "texCoords");
    g_glFuncTable.glBindAttribLocation(this->programHandle, DIFFUSE_ATTRIBUTE_INDEX, "diffuse");

    if(!linkProgram(this->programHandle))
    {
        goto fail;
    }

    g_glFuncTable.glUseProgram(this->programHandle);

    this->uniforms[UNIFORM_MODELVIEW] = g_glFuncTable.glGetUniformLocation(programHandle, "modelviewMatrix");
    this->uniforms[UNIFORM_PROJECTION] = g_glFuncTable.glGetUniformLocation(programHandle, "projectionMatrix");
    this->uniforms[UNIFORM_TEXTURE_MATRIX] = g_glFuncTable.glGetUniformLocation(programHandle, "textureMatrix");

    this->uniforms[UNIFORM_ENV_DIFFUSE] = g_glFuncTable.glGetUniformLocation(programHandle, "envDiffuse");
    this->uniforms[UNIFORM_TEX_COORD_FLAG] = g_glFuncTable.glGetUniformLocation(programHandle, "useTexCoords");
    this->uniforms[UNIFORM_DIFFUSE_FLAG] = g_glFuncTable.glGetUniformLocation(programHandle, "useDiffuse");
    this->uniforms[UNIFORM_TEXTURE_SAMPLER] = g_glFuncTable.glGetUniformLocation(programHandle, "tex");
    this->uniforms[UNIFORM_FOG_NEAR] = g_glFuncTable.glGetUniformLocation(programHandle, "fogNear");
    this->uniforms[UNIFORM_FOG_FAR] = g_glFuncTable.glGetUniformLocation(programHandle, "fogFar");
    this->uniforms[UNIFORM_FOG_COLOR] = g_glFuncTable.glGetUniformLocation(programHandle, "fogColor");
    this->uniforms[UNIFORM_COLOR_OP] = g_glFuncTable.glGetUniformLocation(programHandle, "colorOp");

    for (u32 i = 0; i < ARRAY_SIZE(this->uniforms); i++)
    {
        if (this->uniforms[i] == -1)
        {
            utils::DebugPrint("Get uniform %i location failed!", i);
        }
    }

    // Use texture unit 0 (aka the only one we ever use)
    g_glFuncTable.glUniform1i(this->uniforms[UNIFORM_TEXTURE_SAMPLER], 0);

    identityMatrix.Identity();
    g_glFuncTable.glUniformMatrix4fv(this->uniforms[UNIFORM_MODELVIEW], 1, false, (GLfloat *) &identityMatrix.m);
    g_glFuncTable.glUniformMatrix4fv(this->uniforms[UNIFORM_PROJECTION], 1, false, (GLfloat *) &identityMatrix.m);
    g_glFuncTable.glUniformMatrix4fv(this->uniforms[UNIFORM_TEXTURE_MATRIX], 1, false, (GLfloat *) &identityMatrix.m);

    g_glFuncTable.glUniform1f(this->uniforms[UNIFORM_FOG_FAR], 1.0f);

    g_glFuncTable.glEnableVertexAttribArray(POSITION_ATTRIBUTE_INDEX);

    return true;
fail:
    utils::DebugPrint("GL error: %X\n", g_glFuncTable.glGetError());
    g_glFuncTable.glDeleteProgram(this->programHandle);
    g_glFuncTable.glDeleteShader(this->vertexShaderHandle);
    g_glFuncTable.glDeleteShader(this->fragmentShaderHandle);

    return false;
}

void WebGL::SetFogRange(f32 nearPlane, f32 farPlane)
{
    g_glFuncTable.glUniform1f(this->uniforms[UNIFORM_FOG_NEAR], nearPlane);
    g_glFuncTable.glUniform1f(this->uniforms[UNIFORM_FOG_FAR], farPlane);
}

void WebGL::SetFogColor(ZunColor color)
{
    g_glFuncTable.glUniform4f(this->uniforms[UNIFORM_FOG_COLOR], ((color >> 16) & 0xFF) / 255.0f, 
                                                            ((color >> 8) & 0xFF) / 255.0f,
                                                            (color & 0xFF) / 255.0f,
                                                            ((color >> 24) & 0xFF) / 255.0f);
}

void WebGL::ToggleVertexAttribute(u8 attr, bool enable)
{
    if (attr & VERTEX_ATTR_TEX_COORD)
    {
        if (enable)
        {
            g_glFuncTable.glEnableVertexAttribArray(TEX_COORDS_ATTRIBUTE_INDEX);
            g_glFuncTable.glUniform1i(this->uniforms[UNIFORM_TEX_COORD_FLAG], true);
        }
        else
        {
            g_glFuncTable.glDisableVertexAttribArray(TEX_COORDS_ATTRIBUTE_INDEX);
            g_glFuncTable.glUniform1i(this->uniforms[UNIFORM_TEX_COORD_FLAG], false);
        }
    }

    if (attr & VERTEX_ATTR_DIFFUSE)
    {
        if (enable)
        {
            g_glFuncTable.glEnableVertexAttribArray(DIFFUSE_ATTRIBUTE_INDEX);
            g_glFuncTable.glUniform1i(this->uniforms[UNIFORM_DIFFUSE_FLAG], true);
        }
        else
        {
            g_glFuncTable.glDisableVertexAttribArray(DIFFUSE_ATTRIBUTE_INDEX);
            g_glFuncTable.glUniform1i(this->uniforms[UNIFORM_DIFFUSE_FLAG], false);
        }
    }
}

void WebGL::SetAttributePointer(VertexAttributeArrays attr, std::size_t stride, void *ptr)
{
    switch (attr)
    {
    case VERTEX_ARRAY_POSITION:
        g_glFuncTable.glVertexAttribPointer(POSITION_ATTRIBUTE_INDEX, 3, GL_FLOAT, false, stride, ptr);
        break;
    case VERTEX_ARRAY_TEX_COORD:
        g_glFuncTable.glVertexAttribPointer(TEX_COORDS_ATTRIBUTE_INDEX, 2, GL_FLOAT, false, stride, ptr);
        break;
    case VERTEX_ARRAY_DIFFUSE:
        g_glFuncTable.glVertexAttribPointer(DIFFUSE_ATTRIBUTE_INDEX, 4, GL_UNSIGNED_BYTE, true, stride, ptr);
        break;
    }
}

void WebGL::SetColorOp(TextureOpComponent component, ColorOp op)
{
    if (component == COMPONENT_ALPHA)
    {
        return;
    }

    g_glFuncTable.glUniform1i(this->uniforms[UNIFORM_COLOR_OP], op);
}

void WebGL::SetTextureFactor(ZunColor factor)
{
    g_glFuncTable.glUniform4f(this->uniforms[UNIFORM_ENV_DIFFUSE], ((factor >> 16) & 0xFF) / 255.0f, 
                                                            ((factor >> 8) & 0xFF) / 255.0f,
                                                            (factor & 0xFF) / 255.0f,
                                                            ((factor >> 24) & 0xFF) / 255.0f);
}

void WebGL::SetTransformMatrix(TransformMatrix type, ZunMatrix &matrix)
{
    // I should probably just remove the model matrix from the range of possibilies
    u32 matrixUniformEnum[4] = {UNIFORM_MODELVIEW, UNIFORM_MODELVIEW, UNIFORM_PROJECTION, UNIFORM_TEXTURE_MATRIX};

    g_glFuncTable.glUniformMatrix4fv(this->uniforms[matrixUniformEnum[type]], 1, false, (GLfloat *) &matrix.m);
}

void WebGL::Draw()
{

}
}; // namespace th06
